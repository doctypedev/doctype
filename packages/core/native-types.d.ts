/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

/**
 *
 * Core type definitions for Doctype

 *
 * Reference to a code symbol in the source code

 */
export interface CodeRef {
  /** Absolute path to the source file */
  filePath: string;
  /** Name of the symbol (function, class, interface, etc.) */
  symbolName: string;
}
/**
 * Signature information extracted from code
 */
export interface CodeSignature {
  /** Name of the symbol */
  symbolName: string;
  /** Type of the symbol (function, class, interface, type, etc.) */
  symbolType: SymbolType;
  /** The actual signature text (normalized) */
  signatureText: string;
  /** Whether the symbol is exported */
  isExported: boolean;
}
/**
 * Types of symbols we track
 */
export const enum SymbolType {
  Function = "Function",
  Class = "Class",
  Interface = "Interface",
  TypeAlias = "TypeAlias",
  Enum = "Enum",
  Variable = "Variable",
  Const = "Const",
}
/**
 * Hash information for a code signature
 */
export interface SignatureHash {
  /** SHA256 hash of the signature */
  hash: string;
  /** Original signature that was hashed */
  signature: CodeSignature;
  /** Timestamp when hash was generated */
  timestamp: number;
}
/**
 * Reference to documentation location
 */
export interface DocRef {
  /** Path to the markdown file */
  filePath: string;
  /** Line number where the anchor starts */
  startLine: number;
  /** Line number where the anchor ends */
  endLine: number;
}
/**
 * Complete mapping entry in doctype-map.json
 */
export interface DoctypeMapEntry {
  /** Unique identifier for this anchor */
  id: string;
  /** Reference to the code */
  codeRef: CodeRef;
  /** Hash of the code signature */
  codeSignatureHash: string;
  /** The signature text (for AI context) */
  codeSignatureText?: string;
  /** Reference to the documentation */
  docRef: DocRef;
  /** Original markdown content between anchors */
  originalMarkdownContent: string;
  /** Last updated timestamp */
  lastUpdated: number;
}
/**
 * The complete doctype-map.json structure
 */
export interface DoctypeMap {
  /** Schema version for future compatibility */
  version: string;
  /** All tracked documentation anchors */
  entries: Array<DoctypeMapEntry>;
}
/** Simple hello world function to test the napi binding */
export declare function helloWorld(): string;
/** Get version information */
export declare function getVersion(): string;
/** NAPI-compatible result structure for file discovery */
export interface FileDiscoveryResult {
  /** List of markdown file paths found */
  markdownFiles: Array<string>;
  /** List of source file paths found */
  sourceFiles: Array<string>;
  /** Total number of files found */
  totalFiles: number;
  /** Number of errors encountered */
  errors: number;
}
/** NAPI-compatible options for file discovery */
export interface FileDiscoveryOptions {
  /** Respect .gitignore rules (default: true) */
  respectGitignore?: boolean;
  /** Include hidden files (default: false) */
  includeHidden?: boolean;
  /** Maximum depth to traverse (default: unlimited) */
  maxDepth?: number;
}
/**
 * Discover files in a directory (NAPI binding for Node.js)
 *
 * Scans the given directory and returns all markdown and source files found.
 * Respects .gitignore by default.
 *
 * # Arguments
 * * `root_path` - The root directory to scan
 * * `options` - Optional configuration for the discovery process
 *
 * # Example (Node.js)
 * ```javascript
 * const { discoverFiles } = require('@doctypedev/core');
 *
 * const result = discoverFiles('./src', {
 *   respectGitignore: true,
 *   includeHidden: false,
 *   maxDepth: 5
 * });
 *
 * console.log('Found', result.markdownFiles.length, 'markdown files');
 * console.log('Found', result.sourceFiles.length, 'source files');
 * console.log('Total:', result.totalFiles);
 * ```
 */
export declare function discoverFiles(
  rootPath: string,
  options?: FileDiscoveryOptions | undefined | null,
): FileDiscoveryResult;
/** AST Analyzer for TypeScript/JavaScript code */
export declare class AstAnalyzer {
  /** Create a new AST analyzer instance */
  constructor();
  /**
   * Analyze a TypeScript/JavaScript file and return information
   *
   * This is a placeholder that returns a hello world message.
   * In the future, this will parse the file and extract symbols.
   */
  analyzeFile(filePath: string): string;
  /** Get a list of exported symbols from a file (placeholder) */
  getSymbols(filePath: string): Array<string>;
}
